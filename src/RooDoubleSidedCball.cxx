/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 



#include "Riostream.h" 

#include "RooDoubleSidedCball.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

//ClassImp(RooDoubleSidedCball) 

RooDoubleSidedCball::RooDoubleSidedCball(const char *name, const char *title, 
					 RooAbsReal& _x,
					 RooAbsReal& _mu,
					 RooAbsReal& _sigma,
					 RooAbsReal& _aL,
					 RooAbsReal& _nL,
					 RooAbsReal& _aR,
					 RooAbsReal& _nR) :
RooAbsPdf(name,title), 
  x("x","x",this,_x),
  mu("mu","mu",this,_mu),
  sigma("sigma","sigma",this,_sigma),
  aL("aL","aL",this,_aL),
  nL("nL","nL",this,_nL),
  aR("aR","aR",this,_aR),
  nR("nR","nR",this,_nR)
{ 
  sqrtPiOver2 = 1.2533141373;
  sqrt2 = 1.4142135624;

} 


RooDoubleSidedCball::RooDoubleSidedCball(const RooDoubleSidedCball& other, const char* name) :  
  RooAbsPdf(other,name), 
  x("x",this,other.x),
  mu("mu",this,other.mu),
  sigma("sigma",this,other.sigma),
  aL("aL",this,other.aL),
  nL("nL",this,other.nL),
  aR("aR",this,other.aR),
  nR("nR",this,other.nR)
{ 

  
  sqrtPiOver2 = 1.2533141373;
  sqrt2 = 1.4142135624;

} 



Double_t RooDoubleSidedCball::evaluate() const 
{ 
   double core = (x-mu)/sigma;
   double value = 0;
   
   if(core <= -aL)
     value = exp(-aL*aL*0.5)*pow(1-aL/nL*(aL+core),-nL);
   else if(core >= aR)
     value = exp(-aR*aR*0.5)*pow(1-aR/nR*(aR-core),-nR);
   else if(core>-aL && core<aR)
     value = exp(-0.5*core*core);
   else{
     cout<<"something gone wrong with range"<<endl; 
     cout<<"x "<<x<<" mu "<<mu<<" sigma "<<sigma<<" aL "<<aL<<" nL "<<nL<<" aR "<<aR<<" nR "<<nR<<endl;
     //assert(1==0);
   }
   //cout<<"mu "<<mu<<" sigma "<<sigma<<" aL "<<aL<<" nL "<<nL<<" aR "<<aR<<" nR "<<nR<<endl;

   return value;
   
   
} 

Double_t RooDoubleSidedCball::pointX(double point)const  
{ 
   double core = (point-mu)/sigma;
   double value = 0;
   
   if(core <= -aL)
     value = exp(-aL*aL*0.5)*pow(1-aL/nL*(aL+core),-nL);
   else if(core >= aR)
     value = exp(-aR*aR*0.5)*pow(1-aR/nR*(aR-core),-nR);
   else if(core>-aL && core<aR)
     value = exp(-0.5*core*core);
   else{
     cout<<"something gone wrong with range"<<endl; 
     //assert(1==0);
   }

   return value;
   
   
} 




Int_t RooDoubleSidedCball::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const 
{
  if( matchArgs(allVars,analVars,x) )return 1;
  
  return 0;
}


Double_t RooDoubleSidedCball::analyticalIntegral(Int_t code, const char* rangeName) const
{

  if(code==2){
    return num_test(x.min(rangeName),x.max(rangeName),200000);
  }

  //assert(code==1);
   
  double core_min = (x.min(rangeName)-mu)/sigma;
  double core_max = (x.max(rangeName)-mu)/sigma;

  if(core_min>core_max){
    std::cerr<<"Min(x) > Max(x)"<<std::endl;
    assert(1==0);
  }
  double value= 0;

  
  //std::cout<<" aL "<<aL<<" nL "<<nL<< " aR "<<aR<<" nR "<<nR<<" x min "<<x.min(rangeName)<<" x max "<<x.max(rangeName)<< " sigma " << sigma<<" core_min "<<core_min <<" core_max "<<core_max <<std::endl;



  if(core_max <= -aL){
    value += left_integral(core_min,core_max);
  } 
  else if(core_max>-aL && core_max<aR){
    if(core_min<-aL){
      value += left_integral(core_min,-aL);
      value += gaus_integral(-aL,core_max);
    }
    else if(core_min>-aL && core_min<aR){
      value += gaus_integral(core_min,core_max);
    }
  }
  else if(core_max>= aR){
    if(core_min<-aL){
      value += left_integral(core_min,-aL);
      //cout<<value<<endl;
      value += gaus_integral(-aL,aR);
      //cout<<value<<endl;
      value += right_integral(aR,core_max);
      //cout<<value<<endl;
    }
    else if(core_min>-aL && core_min<aR){
      value += gaus_integral(core_min,aR);
      value += right_integral(aR,core_max);
    }
    else if(core_min>= aR){
      value += right_integral(core_min,core_max);
    }
  }
  
  if(sigma*value<0. || sigma*value!=sigma*value){ 
    std::cout<<" aL "<<aL<<" nL "<<nL<< " aR "<<aR<<" nR "<<nR<<" x min "<<x.min(rangeName)<<" x max "<<x.max(rangeName)<< " sigma " << sigma<<" core_min "<<core_min <<" core_max "<<core_max <<std::endl;
    std::cout<<"gaus "<< gaus_integral(core_min,aR)<<" right "<<right_integral(aR,core_max)<<std::endl;

    std::cout<< sigma*value<<std::endl;
    assert(1==0);
  }





  return sigma*value;



}


Double_t RooDoubleSidedCball::left_integral(Double_t inf,Double_t maxi) const
{
  double value_inf= pow(1-aL/nL*(aL+inf),-nL+1);
  double value_max= pow(1-aL/nL*(aL+maxi),-nL+1);
 
  //std::cout<<"inf "<<inf<<" max "<<maxi<<" value_inf "<<value_inf<<" value_max "<<value_max<<std::endl;

  return nL/aL/(nL-1)*exp(-aL*aL*0.5)*(value_max-value_inf);

}
Double_t RooDoubleSidedCball::gaus_integral(Double_t inf,Double_t maxi)const
{

  //cout<<inf<<" "<<maxi<<" "<<sqrtPiOver2<<" "<<erf(maxi)<<" "<<erf(inf)<<endl;
  //cout<<sqrtPiOver2*(erf(maxi/sqrt2)-erf(inf/sqrt2))<<endl;
  return sqrtPiOver2*(erf(maxi/sqrt2)-erf(inf/sqrt2));

}
Double_t RooDoubleSidedCball::right_integral(Double_t inf,Double_t maxi)const
{
  double value_inf= pow(1-aR/nR*(aR-inf),-nR+1);
  double value_max= pow(1-aR/nR*(aR-maxi),-nR+1);

  //std::cout<<"inf "<<inf<<" max "<<maxi<<" value_inf "<<value_inf<<" value_max "<<value_max<<std::endl;

  return nR/aR/(1-nR)*exp(-aR*aR*0.5)*(value_max-value_inf);

}




Double_t RooDoubleSidedCball::num_test(Double_t min, Double_t max, int steps)const{
  
  double stepSize = (max-min)/(double)steps;
  double intValue = 0;
  

  //cout<<stepSize<<endl;
  int count=0;

  for(int i =0; i<steps;i++){
    intValue += pointX(min+i*stepSize)*stepSize;
    if(round((min+i*stepSize-mu)/sigma*100) == round(-aL*100)&&count ==0){cout<<intValue<<endl;count+=1;}
    if(round((min+i*stepSize-mu)/sigma*100) == round(aR*100)&&count==1){cout<<intValue<<endl;count+=1;}
  }
  

  return intValue;


}
